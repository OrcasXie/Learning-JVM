# JVM

##1_JVM与Java体系结构概述

### HotSpot虚拟机

**JIT编译器**通过计数器找到最具编译价值的代码（即热点代码），触发及时编译，编译成本地机器指令并缓存到方法区，或进行或栈上替换，提升效率。

可以与解释器协同工作，在最优化的程序响应时间与最佳执行性能中取得平衡。

解释器负责程序响应时间，编译器负责性能。

其它虚拟机：

**Graal VM**是基于HotSpot的跨语言全栈虚拟机。

JRockit 专注于服务器端应用，只有编译器，是最快的JVM。

J9类似HotSpot。

Azul VM、BEA Liquid VM与硬件耦合的虚拟机。

Apache Harmony在Android SDK有大范围的应用。



### Class文件内容

（后续补充）

Class 文件是一组以8位字节为基础单位的二进制流，各个数据项严格按顺序排列，没有任何分隔符。

占用空间大于8字节的数据项，按照高位在前的方式分割多个8字节进行存储。

Class 文件格式里只有两种类型：无符号数、表。

每个 Class 文件对应一个 ClassFile 结构：

魔数：CA FE BA BE

https://www.cnblogs.com/timlong/p/8143839.html

### 指令集

Java编译器输入的指令流是基于**栈的指令集架构**，具有跨平台性。指令集小，编译容易实现，但所需的指令多，执行性能比寄存器差。

<img src="https://cdn.jsdelivr.net/gh/OrcasXie/ImgRepo/jvm/zhilingji_LI.jpg" style="zoom: 50%;" />

### JVM整体结构

#### 简图

<img src="https://cdn.jsdelivr.net/gh/OrcasXie/ImgRepo/jvm/RuntimeAreaData.jpg" style="zoom:80%;" />



####详细图

<img src="https://cdn.jsdelivr.net/gh/OrcasXie/ImgRepo/jvm/JVMStructureMore.png" alt="image-20200921160933273" style="zoom:80%;" />



类加载器，执行引擎

## 2_类加载器子系统

### 2.1_类的生命周期

<img src="https://cdn.jsdelivr.net/gh/OrcasXie/ImgRepo/jvm/ClassCircle.jpg" style="zoom:80%;" />

类的生命周期会经历如图7个阶段。

### 2.2_类的加载过程

类的加载过程有3个阶段：加载、连接、初始化。

- **加载：**

  1. 通过一个类的全限定名获取定义此类的二进制字节流；

  2. 将这个字节流所代表的的静态存储结构转化为方法区的运行时数据结构；

  3. 在内存中生成一个代表这个类的`java.lang.Class`对象（反射），作为方法区这个类的各种数据的访问入口。

- **链接：**

  1. 验证：

     - 确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全；

     - 主要包括四种验证，文件格式验证，源数据验证，字节码验证，符号引用验证。

  2. 准备：

     - 为类变量分配内存并且设置该类变量（静态变量）的**默认初始值**，即零值；

     - 这里不包含用`final`修饰的`static`（常量），因为`final`在编译时就会分配了，准备阶段会显式初始化；

     - 这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到 Java 堆中。

  3. 解析：

     - 将常量池内的符号引用转换为直接引用的过程；

     - 解析操作往往会伴随着 JVM 在执行完初始化之后再执行；

     - 符号引用就是一组符号来描述所引用的目标。符号应用的字面量形式明确定义在《java虚拟机规范》的Class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄；

     - 解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的`CONSTANT_Class_info`、`CONSTANT_Fieldref_info`、`CONSTANT_Methodref_info`等。

- **初始化：**

  1. 初始化阶段就是执行类构造器方法`<clinit>()`的过程；

  2. 不需要定义该方法，是 javac 编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来；

  3. 构造器方法中指令按语句在源文件中出现的顺序执行；

  4. **`<clinit>()`不同于类的构造器`<init>()`**；

  5. 若该类有父类，JVM 会保证子类的`<clinit>()`执行前，父类的`<clinit>()`已经执行完毕；
  
  6. 虚拟机必须保证一个类的`<clinit>()`方法在多线程下被同步加锁。

### 2.3_类加载器的分类

- JVM 支持两种类型的加载器，分别为**引导类加载器（`BootStrap ClassLoader`）**和**自定义类加载器**。
- 将所有**派生于抽象类`ClassLoader`**的类加载器都划分为自定义类加载器。(如 `Extension Class Loader`和`System Class Loader`)
- 自定义类默认使用的是系统类加载器进行加载；而Java的核心类库都是使用引导类加载器来加载的。

#### 2.3.1_虚拟机自带的加载器

- **启动类加载器（引导类加载器，`BootStrap Class Loader`）：**
  1. 使用C/C++语言实现，嵌套在JVM内部；
  2. 用于加载 Java 的**核心类库**（`JAVA_HOME/jre/lib/rt.jar/resources.jar或sun.boot.class.path`路径下的内容）；
  3. 并不继承自`java.lang.ClassLoader`，无父加载器，是包含关系；
  4. 加载拓展类和应用程序类加载器，并指定为他们的父加载器；
  5. 出于安全考虑，BootStrap启动类加载器只加载包名为`java、javax、sun`等开头的类。

- **扩展类加载器（`Extension Class Loader`）：**
  1. Java语言编写，由`sun.misc.Launcher$ExtClassLoader`实现；
  2. 派生于`CLassLoader`类；
  3. 父类加载器为启动类加载器；
  4. 从`java.ext.dirs`系统属性所指定的目录中加载类库，或从JDK的安装目录的`jre/lib/ext`子目录（扩展目录）下加载类库。**如果用户创建的 JAR 放在此目录下，也会由拓展类加载器加载。**

- **应用程序类加载器（系统类加载器, `AppClassLoader`）：**
  	1. 同 ExtClassLoader 的 1、2、3；
   	2. 负责加载环境变量 classpath 或系统属性`java.class.path`指定路径下的类库；
   	3. **该类加载器是程序中默认的类加载器**，一般来说，Java应用的类都是由它来完成加载；
   	4. 通过`ClassLoader#getSystemClassLoader()`方法可以获取到该类加载器。



**注：**

从JDK9开始，平台类加载器`PlatformClassLoader`取代了扩展类加载器。

```java
public class ClassLoaderTest {
    public static void main(String[] args) {
        try {
            System.out.println(Class.forName("java.lang.String").getClassLoader());
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
        System.out.println(ClassLoader.getPlatformClassLoader());
        System.out.println(Thread.currentThread().getContextClassLoader());

    }
}
```

输出：

```
null
jdk.internal.loader.ClassLoaders$PlatformClassLoader@48140564
jdk.internal.loader.ClassLoaders$AppClassLoader@2437c6dc
```



#### 2.3.2_用户自定义类加载器

作用：

1. 隔离加载类

2. 修改类加载的方式

3. 拓展加载源

4. 防止源码泄漏

实现步骤：

<img src="https://cdn.jsdelivr.net/gh/OrcasXie/ImgRepo/jvm/customizeClassLoaderStep.png" style="zoom:50%;" />



### 2.4_双亲委派机制

当某个类加载器需要加载某个`.class`文件时，它首先把这个任务委托给他的上级类加载器，递归这个操作，如果上级的类加载器没有加载，自己才会去加载这个类。

![](https://cdn.jsdelivr.net/gh/OrcasXie/ImgRepo/jvm/parentsDelegate.jpg)

**举例：**

自己创建一个和JDK的 String 类相同全限定类名的类（即篡改 String 类）：

```java
package java.lang;

public class String {
    static {
        System.out.println("自定义java.lang.String类的静态代码块");
    }

    public static void main(String[] args) {
        System.out.println("能否打印自定义java.lang.String类的输出语句");
    }
}

```

运行后会报错 `java: 程序包已存在于另一个模块中: java.base`

自定义的`java.lang.String`类与`java.base.java.lang.String`相冲突，因为程序优先委托给上级类加载器，委托到启动类加载器时，发现核心类库中有String类，优先执行该类，而我们自定义的String类就不会被加载。



因此它拥有以下的优点：

- 防止重复加载同一个`.class`。通过委托询问上层，加载过了，就不用再加载一遍。

- 保护程序安全，防止核心 API 被随意修改。Java的核心类库都是被启动类加载器加载，即便篡改了也不会被加载。

  

### 2.5_沙箱安全机制

<img src="https://cdn.jsdelivr.net/gh/OrcasXie/ImgRepo/jvm/sandboxSecurity.png" alt="image-20200911163218635" style="zoom: 50%;" />

### 2.6_补充

**类的主动使用和被动使用**

主动使用在类加载系统中的第三阶段initialization即初始化阶段调用了clinit()方法，而被动使用不会去调用。

主动使用，分为七种情况：

1. 创建类的实例

2. 访问某各类或接口的静态变量，或者对该静态变量赋值

3. 调用类的静态方法

4. 反射 比如Class.forName(com.dsh.jvm.xxx)

5. 初始化一个类的子类

6. java虚拟机启动时被标明为启动类的类

7. JDK 7 开始提供的动态语言支持：java.lang.invoke.MethodHandle实例的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic句柄对应的类没有初始化，则初始化

除了以上七种情况，其他使用java类的方式都被看作是对**类的被动使用，都不会导致类的初始化。**



## 3_运行时数据区

内存是非常重要的系统资源，是硬盘和cpu的中间仓库及桥梁，承载着操作系统和应用程序的实时运行。JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行。**不同的JVM对于内存的划分方式和管理机制存在着部分差异**。

### 3.1_运行时数据区内部结构

**运行时环境：**

每个Java应用程序都有一个Runtime类的实例，该实例允许该应用程序与运行该应用程序的环境进行交互。 当前运行时可以从`getRuntime`方法获得。

<img src="https://cdn.jsdelivr.net/gh/OrcasXie/ImgRepo/jvm/runtimeAreaData02.png" style="zoom:80%;" />

（JDK8的元数据区+JIT编译产物，就是JDK8以前的方法区。）

- 线程独占：每个线程都会有它独立的空间，随线程生命周期而创建和销毁。**本地方法栈、虚拟机栈、程序计数器。**
- 线程共享：所有线程能访问这块内存数据，随虚拟机或GC创建和销毁。**堆、堆外内存（元数据区、代码缓存）。**

### 3.2_JVM中的线程

在HotSpot JVM中，每个线程都与操作系统的本地线程直接映射；

操作系统负责所有线程的安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用Java线程中的`run()`方法；

Java线程执行终止后，本地线程也会回收。



后台线程分类：

- **虚拟机线程：**这种线程的操作时需要JVM达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点，这样堆才不会变化。这种线程的执行包括“stop-the-world”的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销。

- **周期任务线程：**这种线程是时间周期事件的提现（比如中断），他们一般用于周期性操作的调度执行。

- **GC线程：**这种线程对于JVM里不同种类的垃圾收集行为提供了支持。

- **编译线程：**这种线程在运行时会降字节码编译成本地代码。

- **信号调度线程：**这种线程接收信号并发送给JVM,在它内部通过调用适当的方法进行处理。

### 3.3_程序计数器（PC寄存器）

<img src="https://cdn.jsdelivr.net/gh/OrcasXie/ImgRepo/jvm/PCRegister.jpg" style="zoom:67%;" />

PC寄存器是用来存储**指向下一条指令的地址**，也即将要执行的指令代码。由执行引擎读取下一条指令。

- 它是一块很小的内存空间，几乎可以忽略不计。也是运行速度最快的存储区域。
- 在jvm规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。

- 任何时间一个线程都只有一个方法在执行，也就是所谓的**当前方法**。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；或者，如果是在执行native方法，则是未指定值（undefined）。
- 它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。
- 它是唯一一个在java虚拟机规范中**没有规定任何OOM（Out Of Memery）情况**的区域，而且**没有垃圾回收**。

<img src="https://cdn.jsdelivr.net/gh/OrcasXie/ImgRepo/jvm/PCRegister02.jpg" style="zoom:80%;" />



常见问题：

**1、使用PC寄存器存储字节码指令地址有什么用呢？（为什么使用PC寄存器记录当前线程的执行地址呢？）**

（1）多线程宏观上是并行（多个事件在同一时刻同时发生）的，但实际上是并发交替执行的；

（2）因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行；
（3）JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。

众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。

这样必然导致经常中断或恢复，如何保证分毫无差呢？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。

**2、PC寄存器为什么会设定为线程私有？**

（1）所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU会不停的做任务切换，这样必然会导致经常中断或恢复，如何保证分毫无差呢？

（2）为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法是**为每一个线程都分配一个PC寄存器**，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。

### 3.4_Java虚拟机栈

####3.4.1_虚拟机栈的基本概念

- 由于跨平台性的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的。

- **优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。**

- **栈是运行时的单位，而堆是存储的单位。**

- 栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放、放在哪儿。

- 一般来讲，对象主要都是放在堆空间的，是运行时数据区比较大的一块。

- 栈空间存放基本数据类型的局部变量，以及引用数据类型的对象的引用。



##### 虚拟机栈的特点

<img src="https://cdn.jsdelivr.net/gh/OrcasXie/ImgRepo/jvm/stack.jpg" style="zoom:50%;" />

- Java虚拟机栈（Java Virtual Machine Stack），早期也叫 Java栈。 每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的**栈帧**（Stack Frame），对应这个一次次的 Java方法调用。
- 是线程私有的
- 生命周期和线程是一致的
- 作用：主管Java程序的运行，它保存方法的局部变量（8种基本数据类型、对象的引用地址）、部分结果，并参与方法的调用和返回。

  - 局部变量：相较于成员变量（成员变量或称属性）
  - 基本数据变量：8种基本数据类型
  - 引用类型变量：类，数组，接口

- 栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器。
- JVM直接对java栈的操作只有两个：
  - 每个方法执行，伴随着进栈（入栈，压栈）
  - 执行结束后的出栈工作
- 对于栈来说不存在垃圾回收问题，但存在OOM异常。



##### 栈中常见异常

Java虚拟机规范允许**Java栈的大小是动态的或者是固定不变的**。

- 如果采用**固定大小**的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个**`StackOverflowError`**异常。

  ```java
  /** StackOverflowError */
  public class StackErrorTest {
      public static void main(String[] args) {
          main(args);
      }
  }
  ```

  

- 如果Java虚拟机栈可以**动态拓展**，并且在尝试拓展的时候无法申请到足够的内存，或在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出一个 **`OutOfMemoryError`**异常。



##### 设置栈的大小`-Xss`

使用参数`-Xss`选项来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度。 （IDEA设置方法：Run -> EditConfigurations -> VM options 填入指定栈的大小 `-Xss256k`）

```java
/**
 *  StackOverflowError
 *
 * 默认情况下：count = 11336
 * 在设置栈的大小 -Xss256k 后，count = 2363
 */
public class StackErrorTest {
    private static int count = 1;
    public static void main(String[] args) {
        System.out.println(count);
        count ++;
        main(args);
    }
}
```



#### 3.4.2_栈的存储单位与结构

- 每个线程都有自己的栈，栈中的数据都是以**栈帧(Stack Frame)**的格式存在；

- 在这个线程上正在执行的每个方法都对应各自的一个栈帧；

- 栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。

- JVM直接对java栈的操作只有两个，就是对栈帧的**压栈**和**出栈**，遵循**先进后出 / 后进先出**原则。

  <img src="https://cdn.jsdelivr.net/gh/OrcasXie/ImgRepo/jvm/CurrentStack.jpg" style="zoom: 67%;" />

- 在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的，这个栈帧被称为**当前栈帧(Current Frame)**，与当前栈帧对应的方法就是**当前方法（Current Frame）**，当前方法对应的类就是**当前类（Current Class）**。

- 执行引擎运行的所有字节码指令只针对当前栈帧进行操作；

- 如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前栈帧；

- 不同线程中所包含的栈帧是不允许相互引用的，即不能在一个栈帧中引用另外一个线程的栈帧；

- 如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧；

- Java方法有两种返回函数的方式，**一种是正常的函数返回，使用return指令；另外一种是抛出异常。不管使用哪种方式，都会导致栈帧被弹出。**



### 3.5_栈帧

#### 3.5.1_栈帧的内部结构



<img src="https://cdn.jsdelivr.net/gh/OrcasXie/ImgRepo/jvm/StackFrame.jpg" style="zoom: 50%;" />

每个栈帧中存储着：

1. **局部变量表**（Local Variables）

2. **操作数栈**（Operand Stack）（或表达式栈）

3. 动态链接（Dynamic Linking）（或执行"运行时常量池"的方法引用）

4. 方法返回地址（Return Adress）（或方法正常退出或者异常退出的定义）

5. 一些附加信息



#### 3.5.2_局部变量表（Local Variables）

- 局部变量表也被称之为局部变量数组或本地变量表；

- **定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量**，这些数据类型包括各类基本数据类型、对象引用（reference），以及returnAddress类型；

- 由于局部变量表是建立在线程的栈上，是线程私有的数据，因此不存在数据安全问题；

  <img src="https://cdn.jsdelivr.net/gh/OrcasXie/ImgRepo/jvm/MaxLocalVariable.jpg" style="zoom: 67%;" />

- **局部变量表所需的容量大小是在编译期确定下来的**，并保存在方法的Code属性的`maximum local variables`数据项中。在方法运行期间是不会改变局部变量表的大小的；

- **方法嵌套调用的次数由栈的大小决定。**一般来说，**栈越大，方法嵌套调用次数越多。**对一个函数而言，他的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间；

- **局部变量表中的变量只在当前方法调用中有效。**在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。**当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。**



##### Slot变量槽     

(p49-p50的课再看一次)

- 参数值的存放总是在局部变量数组的`index0`开始，到`数组长度-1`的索引结束

- 局部变量表，**最基本的存储单元是Slot(变量槽)**

- 局部变量表中存放编译期可知的各种基本数据类型（8种），引用类型（reference），returnAddress类型的变量。

- 在局部变量表里，**32位以内的类型只占用一个 Slot（包括returnAddress类型），64位的类型（long和double）占用两个 Slot。**
  - byte、short、char、float 在存储前被转换为 int；boolean 也被转换为 int，0 表示 false，非0 表示 true；
  - long 和 double 则占据两个 slot。

- JVM会为局部变量表中的每一个 Slot 都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值；

- 当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会按照**声明顺序**被复制到局部变量表中的每一个 Slot 上；

  <img src="https://cdn.jsdelivr.net/gh/OrcasXie/ImgRepo/jvm/slot.jpg" style="zoom: 50%;" />

- **如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可。**（比如：访问long或者double类型变量）

- 如果当前帧是由构造方法或者实例方法创建的（意思是当前帧所对应的方法是构造器方法或者是普通的实例方法），那么**该对象引用 this 将会存放在 index 为 0 的 Slot 处**,其余的参数按照参数表顺序排列。

- 静态方法中不能引用this，是因为静态方法所对应的栈帧当中的局部变量表中不存在this。

##### 补充

- 在栈帧中，与性能调优关系最为密切的部分就是局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递。
- **局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。**

#### 3.5.3_操作数栈（Operand Stack）

栈 ：可以使用数组或者链表来实现。

- 每一个独立的栈帧中除了包含局部变量表以外，还包含一个后进先出的操作数栈，也可以成为**表达式栈**。

- **操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈（push）/ 出栈（pop）**。
  - 某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用他们后再把结果压入栈。（如字节码指令bipush操作）
  - 比如：执行复制、交换、求和等操作



- 操作数栈，**主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。**
- 操作数栈就是JVM执行引擎的一个工作区，当一个方法开始执行的时候，一个新的栈帧也会随之被创建出来，**这个方法的操作数栈是空的**。
- 每一个操作数栈都会拥有一个明确的**栈深度**用于存储数值，其所需的最大深度在编译器就定义好了，保存在方法的Code属性中，为`max_stack`的值。
- 栈中的任何一个元素都是可以任意的java数据类型
  - 32bit的类型占用一个栈单位深度
  - 64bit的类型占用两个栈深度单位
- 操作数栈**并非采用访问索引的方式来进行数据访问**的，而是只能通过标准的入栈push和出栈pop操作来完成一次数据访问。
- **如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，**并更新PC寄存器中下一条需要执行的字节码指令。
- 操作数栈中的元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译期间进行验证，同时在类加载过程中的类验证阶段的数据流分析阶段要再次验证。
- 另外，我们说Java虚拟机的**解释引擎是基于栈的执行引擎**,其中的栈指的就是操作数栈。



#### 3.5.4_栈顶缓存技术（Top-of-Stack Cashing）

- 基于栈式架构的虚拟机所使用的零地址指令（即不考虑地址，单纯入栈出栈）更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数和内存读/写次数
- 由于操作数是存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存技术，**将栈顶元素全部缓存在物理CPU的 *寄存器* 中，以此降低对内存的读/写次数，提升执行引擎的执行效率**。



#### 3.5.5_动态链接（Dynamic Linking）

运行时常量池位于方法区（注意： JDK1.7 及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。）

- 每一个栈帧内部都包含一个指向**运行时常量池`Constant pool`**中**该栈帧所属方法的引用**。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接。比如：`invokedynamic`指令。

  ![](https://cdn.jsdelivr.net/gh/OrcasXie/ImgRepo/jvm/SymbolRef.jpg)

- 在Java源文件被编译成字节码文件中时，所有的变量和方法引用都作为符号引用（Symbolic Refenrence）保存在class字节码文件的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么**动态链接的作用就是为了将这些符号引用（#n）转换为调用方法的直接引用。**

<img src="https://cdn.jsdelivr.net/gh/OrcasXie/ImgRepo/jvm/DynamicLink.jpg" style="zoom:80%;" />





####3.5.6_方法的调用：解析和分派

在 JVM 中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关。

- **静态链接**
  当一个字节码文件被装载进 JVM 内部时，如果**被调用的目标方法在编译期可知**，且运行期保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接。
- **动态链接**
  如果**被调用的方法在编译期无法被确定下来**，也就是说，只能够在程序**运行期**将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接。

对应的方法的绑定机制为：早期绑定（Early Binding）和晚期绑定（Late Binding）。**绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，仅发生一次**。

- **早期绑定**
  早期绑定就是指被调用的目标方法如果在**编译期**可知，且运行期保持不变时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。
- **晚期绑定**
  如果被调用的方法在编译期无法被确定下来，只能够在程序**运行期**根据实际的类型绑定相关的方法，这种绑定方式也就被称之为晚期绑定。（多态）

基于面向对象的编程语言始终保持着一个共性，那就是都支持封装，集成和多态等面向对象特性。既然这一类的编程语言具备多态特性，那么自然也就具备早期绑定和晚期绑定两种绑定方式。

Java中任何一个普通的方法其实都具备**虚函数**的特征，它们相当于C++语言中的虚函数（C++中则需要使用关键字virtual来显式定义）。如果在Java程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字`final`来标记这个方法（编译器被确定）。

##### 虚方法和非虚方法

**非虚方法**

- 如果方法在**编译期**就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法。
- **静态方法、私有方法、final方法、实例构造器（实例已经确定，this()调用本类的构造器）、父类方法（super调用）都是非虚方法**。（不能被重写）

- 其他所有体现多态特性的方法称为**虚方法**。

子类对象的**多态性**使用前提：

​       ① 类的继承关系

​       ② 方法的重写

实际开发编写代码中用的接口，实际执行是导入的的三方jar包已经实现的功能



**虚拟机中提供了以下几条方法调用指令：**

- 普通调用指令：
  - `invokestatic`：调用静态方法，解析阶段确定唯一方法版本
  - `invokespecial`：调用<init>方法、私有及父类方法，解析阶段确定唯一方法版本
  - `invokevirtual`：调用所有虚方法
  - `invokeinterface`：调用接口方法
- 动态调用指令：
  - `invokedynamic`：动态解析出需要调用的方法，然后执行 。（Java7新增）

前四条指令固化在虚拟机内部，方法的调用执行不可人为干预，而`invokedynamic`指令则支持由用户确定方法版本。

**`invokestatic`指令和`invokespecial`指令调用的方法称为非虚方法；**

**`invokevirtual`（final修饰的除外，final为非虚方法）、`invokeinterface`指令调用的方法称称为虚方法。**



**invokedynamic**

- JVM字节码指令集一直比较稳定，一直到 Java7 才增加了一个`invokedynamic`指令，这是**Java为了实现【动态类型语言】支持而做的一种改进**；
- 但是 Java7 中并没有提供直接生成`invokedynamic`指令的方法，需要借助 ASM 这种底层字节码工具来产生`invokedynamic`指令。**直到Java8的 Lambda 表达式的出现，`invokedynamic`指令的生成，在Java中才有了直接生成方式**；
- Java7 中增加的动态语言类型支持的本质是对Java虚拟机规范的修改，而不是对Java语言规则的修改，这一块相对来讲比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是运行在Java平台的动态语言的编译器。



**动态类型语言和静态类型语言**

- 动态类型语言和静态类型语言两者的却别在于对类型的检查是在编译期还是在运行期，满足前者就是静态类型语言，反之则是动态类型语言。
- 直白来说， **静态语言是判断变量自身的类型信息；动态类型语言是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息**，这是动态语言的一个重要特征。
- Java是静态类型语言（尽管lambda表达式为其增加了动态特性），js，python是动态类型语言。



```java
Java：String info = "Orcas"; //静态语言

JS：var name = "Orcas“；var name = 10; //动态语言

Python: info = 130; //动态语言
```

虽然 Java 在 JDK10时引入了var，可以局部变量类型推断，但 var 在**编译阶段**会被替换成所赋值的类型，因此 Java 依旧是一门静态语言。



方法返回地址





# 附录

#### 显示当前所有java进程pid的命令

JPS

####加载 .class 文件的方式

<img src="https://cdn.jsdelivr.net/gh/OrcasXie/ImgRepo/jvm/way2loadClassfile.png" alt="image-20200910163730223" style="zoom:50%;" />

#### CPU时间片

<img src="https://cdn.jsdelivr.net/gh/OrcasXie/ImgRepo/jvm/cpuTimeSlice.jpg" style="zoom:50%;" />